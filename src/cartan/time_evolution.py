"""
time_evolution
--------------
This module contains functions to find the time evolution unitary in matrix form. It can find the exact unitary, a
trotterized unitary and the unitary generated from a Cartan decomposition.
"""

import numpy as np
import scipy.linalg as la
from numpy.typing import NDArray

STRING_TO_MATRIX = {'I': [[1, 0], [0, 1]], 'X': [[0, 1], [1, 0]], 'Y': [[0, -1j], [1j, 0]], 'Z': [[1, 0], [0, -1]],
                    0: [[1, 0], [0, 1]], 1: [[0, 1], [1, 0]], 2: [[0, -1j], [1j, 0]], 3: [[1, 0], [0, -1]]}


def _singles_product(angles: list[float], strings: list[str | tuple[int]]) -> NDArray:
    """
    Finds the matrix representation of a product of exponentials of single Pauli strings.

    Parameters:
    ----------
    angles : list[float]
        The rotation angles.
    strings : list[str | tuple[int]]
        The Pauli strings.

    Returns:
    --------
    unitary : NDArray
        The matrix exponential.
    """
    N = len(strings[0])
    unitary = np.identity(2 ** N)
    identity = np.identity(2 ** N)

    for i in range(len(strings)):
        string_matrix = STRING_TO_MATRIX[strings[i][0]]
        for j in range(len(strings[i]) - 1):
            string_matrix = np.kron(string_matrix, STRING_TO_MATRIX[strings[i][j + 1]])
        unitary = unitary @ (np.cos(angles[i]) * identity + 1j * np.sin(angles[i]) * string_matrix)
    return unitary


def exact_unitary(hamiltonian_dict: dict[str | tuple[int], float], simulation_time: float) -> NDArray:
    """
    Finds the exact unitary generated by a Hamiltonian.

    Parameters:
    -----------
    hamiltonian_dict : dict[str | tuple[int], float]
        The Hamiltonian dictionary.
    simulation_time : float
        The total simulation time.

    Returns:
    --------
    NDArray
        The matrix exponential of the Hamiltonian.
    """
    unitary_generator = np.zeros(2 ** len(next(iter(hamiltonian_dict))))
    for hamiltonian_string in hamiltonian_dict.keys():
        string_matrix = STRING_TO_MATRIX[hamiltonian_string[0]]
        for j in range(len(hamiltonian_string) - 1):
            string_matrix = np.kron(string_matrix, STRING_TO_MATRIX[hamiltonian_string[j + 1]])
        unitary_generator = unitary_generator + hamiltonian_dict[hamiltonian_string] * string_matrix
    return la.expm(-1j * simulation_time * unitary_generator)


def trotter_unitary(hamiltonian_dict: dict[str | tuple[int], float],
                    simulation_time: float,
                    steps: int) -> tuple[NDArray, NDArray]:
    """
    Finds the trotter unitary generated by a Hamiltonian.

    Parameters:
    ----------
    hamiltonian_dict : dict[str | tuple[int], float]
        The Hamiltonian dictionary.
    simulation_time : float
        The total simulation time.
    steps : int
        Number of Trotter steps.

    Returns:
    --------
    unitary : NDArray
        The full Trotter unitary matrix.
    onestep : NDArray
        The matrix of a single Trotter step.
    """
    time_step = simulation_time / steps
    theta = -time_step * np.array(list(hamiltonian_dict.values()))
    onestep = _singles_product(theta, list(hamiltonian_dict.keys()))  # type: ignore

    unitary = onestep.copy()
    for i in range(steps - 1):
        unitary = unitary @ onestep

    return unitary, onestep


def cartan_unitary(angles: list[float],
                   generators: list[str | tuple[int]],
                   subalgebra_dict: dict[str | tuple[int], float],
                   simulation_time: float) -> NDArray:
    """
    Finds the matrix of a unitary based on a Cartan decomposition.

    Parameters:
    -----------
    angles : list[float]
        The rotation angles in the K unitary.
    generators : list[str | tuple[int]]
        The Pauli strings in the K unitary.
    subalgebra_dict : dict[str | tuple[int], float]
        The transformed Hamiltonian in the Cartan subalgebra.
    simulation_time : float
        The total simulation time.

    Returns:
    --------
    NDArray
        The unitary as a matrix.
    """
    unitary = _singles_product(angles, generators)
    h_angles = -simulation_time * np.array(list(subalgebra_dict.values()))
    h_strings = list(subalgebra_dict.keys())
    unitary = unitary @ _singles_product(h_angles, h_strings)  # type: ignore
    reversed_angles = -np.array(angles[::-1])
    reversed_generators = generators[::-1]
    return unitary @ _singles_product(reversed_angles, reversed_generators)
